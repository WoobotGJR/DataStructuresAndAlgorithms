package org.woobolt.algorithms.bfs;

import java.util.PriorityQueue;
import java.util.Queue;

// Комментарии по сути те же, за исключением замены стека на очередь и самого bfs

/*а помечается как посещенная и добавляется в очередь.
Пока очередь не пуста:
    Извлекается вершина из очереди.
    Для каждой непосещенной смежной вершины этой вершины:
        Вершина помечается как посещенная.
        Она выводится.
        Добавляется в очередь.
В конце метода все флаги посещения сбрасываются.*/

public class BfsGraph {
    private final int MAX_VERTS = 10;
    private BfsVertex vertexList[]; //массив вершин
    private int adjMat[][]; // матрица смежности
    private int nVerts; // текущее количество вершин
    private Queue<Integer> queue;

    public BfsGraph() {
        vertexList = new BfsVertex[MAX_VERTS];
        adjMat = new int[MAX_VERTS][MAX_VERTS];
        nVerts = 0;
        for (int j = 0; j < MAX_VERTS; j++) {
            for (int k = 0; k < MAX_VERTS; k++) {  // заполнение матрицы смежности нулями
                adjMat[j][k] = 0;
            }
        }
        queue = new PriorityQueue<>();
    }

    public void addVertex(char lab) {
        vertexList[nVerts++] = new BfsVertex(lab);
    }

    public void addEdge(int start, int end) {
        adjMat[start][end] = 1;
        adjMat[end][start] = 1;
    }

    public void displayVertex(int v) {
        System.out.println(vertexList[v].getLabel());
    }

    /*
     * Вот как работает этот метод:
     *
     * Начальная вершина графа помечается как посещенная и добавляется в очередь.
     * Пока очередь не пуста: Извлекается вершина из головы очереди. Для каждой
     * непосещенной смежной вершины этой вершины: Вершина помечается как посещенная.
     * Она добавляется в очередь. Выводится значение извлеченной вершины или
     * выполняется другая операция над ней. Этот процесс повторяется до тех пор,
     * пока очередь не станет пустой.
     *
     * В конечном итоге, когда очередь становится пустой, все вершины графа,
     * достижимые из начальной вершины, будут посещены.
     *
     * Процесс обхода графа в ширину начинается с вершины, с которой начинается
     * поиск (в вашем случае это вершина с индексом 0). Затем все смежные с ней
     * вершины добавляются в очередь. После этого извлекается первая вершина из
     * очереди, и процесс повторяется для каждой смежной вершины, пока все вершины
     * не будут посещены.
     *
     * Очередь используется для того, чтобы гарантировать, что вершины будут
     * посещаться в порядке их добавления в очередь, что и обеспечивает порядок
     * обхода графа в ширину.
     */

    public void bfs() { // обход в глубину
        vertexList[0].setWasVisited(true);
        displayVertex(0);
        queue.add(0);
        int v2;

        while (!queue.isEmpty()) {
            int v = queue.remove();

            while((v2 = getAdjUnvisitedVertex(v))!=-1) {// цикл будет работать, пока все смежные вершины не будут найденны, и не будут добавлены в очередь
                vertexList[v2].wasVisited =true;
                displayVertex(v2);
                queue.add(v2);
            }
        }

        for (int j = 0; j < nVerts; j++) {  // сброс флагов
            vertexList[j].wasVisited = false;
        }

    }

    private int getAdjUnvisitedVertex(int v) {
        for (int j = 0; j < nVerts; j++) {
            if (adjMat[v][j] == 1 && vertexList[j].wasVisited == false) {
                return j; //возвращает первую найденную вершину
            }
        }
        return -1;
    }
}

/*
 * PriorityQueue в Java - это реализация очереди, которая использует приоритеты
 * для определения порядка извлечения элементов. Элементы в очереди могут быть
 * извлечены не в порядке их добавления, а в порядке, определяемом их
 * приоритетом. Это означает, что элементы с более высоким приоритетом будут
 * извлечены раньше, чем элементы с более низким приоритетом.
 *
 * PriorityQueue в Java реализована как неупорядоченная очередь с приоритетом на
 * основе двоичной кучи (binary heap). Двоичная куча - это структура данных,
 * которая обеспечивает быстрое добавление и удаление элементов с наименьшим
 * (или наибольшим) значением.
 *
 * Некоторые важные методы PriorityQueue в Java включают:
 *
 * add(E e): Добавляет элемент в очередь. peek(): Возвращает элемент с наивысшим
 * приоритетом без удаления его из очереди. poll(): Возвращает и удаляет элемент
 * с наивысшим приоритетом из очереди. isEmpty(): Проверяет, пуста ли очередь.
 * size(): Возвращает количество элементов в очереди.
 *
 * PriorityQueue может использоваться для решения различных задач, включая
 * планирование задач с разными приоритетами, алгоритмы поиска кратчайшего пути,
 * а также в других случаях, когда требуется обработка элементов в порядке их
 * приоритета.
 */
/*
 * При реализации поиска в ширину (BFS - Breadth-First Search) вместо обычной
 * очереди (Queue) используется PriorityQueue для обеспечения определенного
 * порядка обработки вершин. Это позволяет выполнять обход графа в порядке,
 * определяемом по уровням, что характерно для BFS.
 *
 * В BFS каждый уровень графа обходится до того, как переходить к следующему
 * уровню. Это означает, что все вершины на одном уровне должны быть обработаны,
 * прежде чем переходить к вершинам следующего уровня.
 *
 * PriorityQueue позволяет обеспечить такой порядок обхода графа. Вместо того,
 * чтобы добавлять вершины в очередь в порядке их появления, они добавляются с
 * учетом их "приоритета". В контексте BFS приоритет может быть связан с уровнем
 * вершины в графе: вершины на более низком уровне имеют более высокий
 * приоритет, чем вершины на более высоком уровне.
 *
 * Использование PriorityQueue позволяет гарантировать, что вершины на каждом
 * уровне графа будут обработаны перед переходом к следующему уровню. Это
 * обеспечивает корректность работы алгоритма BFS.
 */
/*
 * В данном алгоритме BFS с использованием PriorityQueue приоритет не задается
 * явным образом. Вместо этого, приоритет определяется порядком добавления
 * элементов в очередь и специальной логикой сравнения элементов.
 *
 * Как правило, в Java PriorityQueue использует реализацию мин-кучи (min-heap),
 * в которой элементы с наименьшим приоритетом извлекаются первыми. Это
 * означает, что для элементов, добавленных с меньшим значением (например, целые
 * числа, если использовать Integer), будет определен более высокий приоритет.
 *
 * В контексте BFS с PriorityQueue вершины графа добавляются в очередь в порядке
 * их появления, и при извлечении вершины из очереди выбирается вершина с более
 * низким индексом, что соответствует вершинам на текущем уровне графа.
 *
 * Таким образом, при использовании PriorityQueue в алгоритме BFS приоритет не
 * устанавливается явным образом, а определяется порядком добавления вершин в
 * очередь и логикой сравнения элементов.
 */
/*
 * В общем случае для BFS можно использовать обычную очередь (Queue) для
 * хранения вершин, которые нужно обойти. Это вполне достаточно для правильной
 * работы алгоритма BFS.
 *
 * Однако использование PriorityQueue в данной реализации BFS может иметь
 * некоторые преимущества или быть полезным в определенных сценариях:
 *
 * Параллельное выполнение задач с различными приоритетами: Если задачи в графе
 * имеют различные приоритеты, то использование PriorityQueue позволяет
 * обрабатывать задачи с более высоким приоритетом раньше, что может быть
 * полезным в некоторых приложениях.
 *
 * Оптимизация времени выполнения: В некоторых случаях использование
 * PriorityQueue может привести к оптимизации времени выполнения, особенно если
 * граф имеет большую глубину и ширину. Приоритетная очередь может позволить
 * сначала обрабатывать вершины на нижних уровнях графа, что может ускорить
 * поиск решения.
 *
 * Адаптивность к изменению графа: Использование PriorityQueue может сделать
 * алгоритм более адаптивным к изменениям в графе во время выполнения, так как
 * позволяет легко изменять порядок обхода вершин.
 *
 * Улучшение моделирования событий: В некоторых симуляциях или моделях событий
 * обычная очередь может быть недостаточной, и PriorityQueue может предложить
 * более гибкое управление порядком обработки событий в зависимости от их
 * приоритета.
 *
 * В целом, использование PriorityQueue в BFS не является стандартной практикой,
 * но в определенных сценариях может быть полезным для оптимизации или адаптации
 * алгоритма к конкретным требованиям или характеристикам графа.
 */