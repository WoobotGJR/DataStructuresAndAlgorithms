package org.woobolt.algorithms;

public class ModifiedHanoiTower {
    public static void main(String[] args) {
        int n = 3; // Количество дисков
        char fromRod = 'A'; // Исходный стержень
        char toRod = 'C'; // Целевой стержень
        char auxRod = 'B'; // Вспомогательный стержень

        // Вызываем метод для перемещения дисков
        moveDisks(n, fromRod, toRod, auxRod);
    }

    // Метод для перемещения дисков
    public static void moveDisks(int n, char fromRod, char toRod, char auxRod) {
        // Базовый случай: если есть только один диск, перемещаем его и выходим
        if (n == 1) {
            System.out.println("Move disk 1 from rod " + fromRod + " to rod " + toRod);
            return;
        }

        // Рекурсивно перемещаем (n-1) дисков с исходного стержня на вспомогательный стержень
        moveDisks(n - 1, fromRod, auxRod, toRod);
        // Перемещаем самый большой диск с исходного стержня на целевой
        System.out.println("Move disk " + n + " from rod " + fromRod + " to rod " + toRod);
        // Рекурсивно перемещаем (n-1) дисков с вспомогательного стержня на целевой стержень
        moveDisks(n - 1, auxRod, toRod, fromRod);
    }
}
/*
    Вот модифицированный алгоритм:

    Базовый случай: Если у нас есть только один диск, перемещение его на целевой стержень - это единственный ход.

    Рекурсивный шаг: Предположим, что мы умеем перемещать (n-1) дисков на любой стержень. Тогда, чтобы переместить n
    дисков с исходного стержня на целевой, мы можем:
    Рекурсивно переместить (n-1) дисков на любой другой стержень.
    Переместить самый большой диск на целевой стержень.
    Рекурсивно переместить (n-1) дисков с вспомогательного стержня на целевой стержень.

    Этот процесс будет рекурсивно повторяться, пока все диски не будут перемещены на целевой стержень.
*/
